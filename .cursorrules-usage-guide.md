# üéØ `.cursorrules-be` Usage Guide

## **What Is This?**

`.cursorrules-be` is a **backend code generator prompt**. You feed it a structured feature description, and it outputs:

1. Complete API endpoints
2. Database models
3. Cache structures  
4. Auth rules
5. Sync logic
6. Error handling
7. Step-by-step integration plan

---

## üöÄ **Quick Start**

### **1. Prepare Your Input**
Use `BACKEND_WIRING_INPUT_TEMPLATE.md` and fill all 5 sections:
- Feature name
- Frontend context
- Backend stack
- Data persistence rules
- Offline/online expectations

### **2. Feed It**
```
@.cursorrules-be Here's my feature input:

[Paste your filled template]
```

### **3. Get Output**
You'll receive a complete backend implementation plan.

### **4. Implement**
Follow the plan step-by-step.

---

## üìã **What Makes a Good Input?**

### ‚úÖ **GOOD Example:**
```markdown
Feature: Starred Documents

Frontend: User clicks star icon on document card ‚Üí Document is marked as starred ‚Üí Shows in "Starred" filter

API Call: 
await documentService.toggleStar(documentId)
// Response: { starred: boolean, starredAt: timestamp }

Storage: PostgreSQL (documents.is_starred, documents.starred_at)

Auth: User must own workspace

Offline: Star locally, sync on reconnect, merge conflicts (keep both starred if conflict)
```

### ‚ùå **BAD Example:**
```markdown
Feature: Stars

Frontend: User can star documents

Storage: Database

Offline: Support offline
```

The first is **specific and actionable**. The second is vague.

---

## üéì **How to Handle "Dynamic Shit"**

You're worried about changing requirements. Here's how to stay flexible:

### **1. Version Your Inputs**
```
features/
  tags-v1-input.md       # Initial version
  tags-v2-input.md       # After requirements change
  tags-v3-input.md       # After user feedback
```

### **2. Use Placeholders for Unknowns**
```markdown
Data Persistence: 
  - PostgreSQL (confirmed)
  - Redis (TBD: depends on autocomplete performance)
  - WebSocket (TBD: if real-time required)
```

### **3. Iterate in Phases**
```markdown
Phase 1: Basic CRUD (no real-time, no offline)
Phase 2: Add WebSocket support
Phase 3: Add offline sync
```

Feed each phase separately to `.cursorrules-be`.

### **4. Reference Existing Patterns**
```markdown
"Use the same pattern as Document CRUD (documents.py, DocumentService)"
"Follow Workspace isolation rules (check user_id via JWT)"
"Cache like we do for workspace list (Redis, 5min TTL)"
```

This keeps consistency even as features evolve.

---

## üî• **Real-World Example: Adding Search**

### **Input to `.cursorrules-be`:**

```markdown
Feature: Full-Text Document Search
Priority: High
Epic: Phase 3

FRONTEND CONTEXT:
- SearchBar component (src/components/search/SearchBar.tsx)
  - User types query ‚Üí Debounced API call ‚Üí Shows results dropdown
  - Click result ‚Üí Navigate to document
  
API Call:
const results = await searchService.search(workspaceId, query, {
  filters: { tags: ["urgent"], dateRange: "last-week" },
  limit: 20
})
// Response: { results: SearchResult[], total: number }

BACKEND STACK:
- FastAPI + PostgreSQL
- Full-text search via PostgreSQL `tsvector`
- Cache popular searches in Redis (1 hour)

DATA PERSISTENCE:
- Index: `documents.search_vector (tsvector)`
- Update on save: `UPDATE documents SET search_vector = to_tsvector('english', title || ' ' || content)`
- Cache: Redis key `search:{workspace_id}:{query_hash}` ‚Üí results

OFFLINE/ONLINE:
- Online: Real-time search via API
- Offline: Local Fuse.js search on cached documents
- Sync: Download document metadata for search index
```

### **Output from `.cursorrules-be`:**
You'd get:
1. FastAPI router with `/api/v1/search` endpoint
2. SQL for creating `tsvector` index
3. Redis caching logic
4. Offline Fuse.js configuration
5. Step-by-step integration guide

---

## üí° **Dynamic Requirements Strategies**

### **Strategy 1: Modular Inputs**
Break features into independent modules:

```
Input 1: Tag CRUD (basic create/read/delete)
Input 2: Tag autocomplete (Redis cache + search)
Input 3: Tag real-time sync (WebSocket updates)
```

If requirements change, you only regenerate affected inputs.

### **Strategy 2: Feature Flags**
```markdown
Feature: Advanced Tag Filters

Configuration:
- ENABLE_TAG_COLORS=true (Phase 1)
- ENABLE_TAG_HIERARCHY=false (Phase 2 - TBD)
- ENABLE_TAG_TEMPLATES=false (Phase 3 - TBD)

Implementation: Use environment variables to toggle features
```

### **Strategy 3: Extensible Models**
```markdown
Database Model:
- tags.metadata (JSONB) ‚Üê Store flexible data here

Future additions can go in metadata without schema changes:
  - tags.metadata.priority (for Phase 2)
  - tags.metadata.icon (for Phase 3)
```

---

## üõ†Ô∏è **Workflow for Changing Requirements**

Let's say you implemented "Tags" but now need "Hierarchical Tags":

### **Step 1: Create New Input**
```bash
cp features/tags-input.md features/tags-hierarchical-input.md
```

### **Step 2: Add Changes**
```markdown
NEW REQUIREMENTS:
- Tags can have parent tags
- Max 3 levels deep
- UI shows tree structure

CHANGED:
- Database: Add tags.parent_id column
- API: New endpoint GET /api/v1/tags/tree
- Frontend: Use tree component instead of flat list
```

### **Step 3: Feed Updated Input**
```
@.cursorrules-be Here's an UPDATE to the Tags feature:
[Paste updated template]

Previous implementation: features/tags-input.md
Changes needed: Add hierarchical support
```

### **Step 4: Get Migration Plan**
You'll receive:
- Alembic migration for new column
- Updated API endpoints
- Frontend integration changes
- Data migration script (if needed)

---

## üìä **Input Quality Checklist**

Before feeding to `.cursorrules-be`:

| Aspect | Question | Status |
|--------|----------|--------|
| **Clarity** | Can a new dev understand this? | ‚òê |
| **Completeness** | Are all 5 sections filled? | ‚òê |
| **Specificity** | No vague terms like "handle errors"? | ‚òê |
| **Examples** | Included code snippets/API calls? | ‚òê |
| **Edge Cases** | Listed 3+ error scenarios? | ‚òê |
| **Auth** | Who can do what? | ‚òê |
| **Offline** | Offline behavior specified? | ‚òê |
| **Sync** | Conflict resolution strategy? | ‚òê |
| **Testing** | How to validate this works? | ‚òê |

---

## üéØ **Template for Quick Features**

For small features, use this condensed template:

```markdown
@.cursorrules-be

FEATURE: [Name]

WHAT: [1 sentence description]

FRONTEND: [Component + action + expected result]

API: [Exact endpoint + payload + response]

DATABASE: [Table + columns]

AUTH: [Who can access]

OFFLINE: [Yes/No + if yes, how sync]

EXAMPLE:
  User clicks "Archive" button on document card
  ‚Üí POST /api/v1/documents/{id}/archive
  ‚Üí Response: { archived: true, archived_at: "2024-01-01T12:00:00Z" }
  ‚Üí Document disappears from main list
  ‚Üí Shows in "Archived" filter
```

---

## üöÄ **Advanced: Multi-Feature Inputs**

For related features, combine inputs:

```markdown
@.cursorrules-be

FEATURE GROUP: Document Organization Suite

FEATURES:
1. Tags (as described in tags-input.md)
2. Starred documents (toggle favorite)
3. Recent documents (last 10 accessed)
4. Custom filters (save search criteria)

SHARED:
- All use same workspace isolation
- All need offline support
- All sync on reconnect

INTERACTIONS:
- Starred + Tagged documents can be filtered together
- Recent documents show their tags
- Custom filters can include starred/tagged criteria
```

You'll get a cohesive plan for all features with shared infrastructure.

---

## üéì **Learning From Existing Code**

MDReader already has patterns. Reference them in inputs:

```markdown
AUTH: Use same JWT validation as in dependencies/auth.py

CACHING: Follow workspace caching pattern (WorkspaceService.py)

WEBSOCKET: Extend WebSocket manager like document presence

DATABASE: Mirror document.py structure (BaseModel + SoftDeleteMixin)

API RESPONSE: Use same error format as other routers (HTTPException)
```

This ensures consistency and speeds up implementation.

---

## ‚úÖ **Summary: Control the "Dynamic Shit"**

1. **Use the template** - Forces you to think through everything
2. **Version inputs** - Keep history of requirement changes
3. **Modular features** - Break big features into small inputs
4. **Reference existing code** - Maintain consistency
5. **Iterate in phases** - Start simple, add complexity
6. **Document unknowns** - Mark TBD items clearly
7. **Update incrementally** - Feed changes as deltas

With this system, you can handle:
- ‚úÖ Changing requirements
- ‚úÖ New features mid-development
- ‚úÖ User feedback iterations
- ‚úÖ Technical debt refactoring
- ‚úÖ Scale from MVP to production

---

## üéâ **You're Ready!**

1. Open `BACKEND_WIRING_INPUT_TEMPLATE.md`
2. Pick your next feature
3. Fill the template
4. Feed it to `.cursorrules-be`
5. Get a complete backend plan
6. Ship it! üöÄ

**The "dynamic shit" is now under control.** üí™

