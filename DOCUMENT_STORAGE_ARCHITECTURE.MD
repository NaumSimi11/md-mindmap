ğŸ“¦ Document Storage Architecture
Three Storage Locations, Two Formats
â”‚  1ï¸âƒ£ IndexedDB (Guest/Backend Cache)                         â”‚

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚                    DOCUMENT STORAGE                          â”‚â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚                                                              â”‚â”‚  1ï¸âƒ£ IndexedDB (Guest/Backend Cache)                         â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚â”‚  â”‚  Database: "MDReaderGuest"             â”‚                 â”‚â”‚  â”‚  Table: "documents"                    â”‚                 â”‚â”‚  â”‚  â”œâ”€â”€ content: "Plain Text Markdown"    â”‚ â† ğŸ“ Metadata  â”‚â”‚  â”‚  â”œâ”€â”€ yjsStateB64: "Base64 String"      â”‚ â† ğŸ§¬ Binary    â”‚â”‚  â”‚  â”œâ”€â”€ title, tags, starred, etc.        â”‚                 â”‚â”‚  â”‚  â””â”€â”€ syncStatus: 'local' | 'synced'    â”‚                 â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚â”‚                                                              â”‚â”‚  2ï¸âƒ£ IndexedDB (Yjs - Separate Database)                     â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚â”‚  â”‚  Database: "mdreader-{documentId}"     â”‚                 â”‚â”‚  â”‚  â”œâ”€â”€ updates: Binary CRDT operations   â”‚ â† ğŸ§¬ Real-time â”‚â”‚  â”‚  â”œâ”€â”€ state: Current Yjs document       â”‚                 â”‚â”‚  â”‚  â””â”€â”€ syncedAt: Last sync timestamp     â”‚                 â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚â”‚                                                              â”‚â”‚  3ï¸âƒ£ PostgreSQL (Cloud Backend)                              â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚â”‚  â”‚  Table: "documents"                    â”‚                 â”‚â”‚  â”‚  â”œâ”€â”€ content: TEXT (Markdown)          â”‚ â† ğŸ“ Fallback  â”‚â”‚  â”‚  â”œâ”€â”€ yjs_state: BYTEA (Binary)         â”‚ â† ğŸ§¬ Truth     â”‚â”‚  â”‚  â”œâ”€â”€ yjs_version: INTEGER              â”‚                 â”‚â”‚  â”‚  â””â”€â”€ title, workspace_id, etc.         â”‚                 â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚â”‚                                                              â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ğŸ” Detailed Breakdown
1. IndexedDB (Document Metadata + Cache)
Location: Browser storage
Databases:
MDReaderGuest (logged out)
MDReaderBackendCache (logged in)
Format:
DocumentMeta
interface DocumentMeta {  id: string;  title: string;  content: string;          // ğŸ“ PLAIN TEXT MARKDOWN (cache/fallback)  yjsStateB64?: string;     // ğŸ§¬ BASE64-ENCODED YJS BINARY (CRDT state)  starred: boolean;  tags: string[];  syncStatus: 'local' | 'synced' | 'syncing' | 'conflict';  // ... other metadata}
Purpose:
âœ… Fast metadata queries (list documents, search, filter)
âœ… Fallback content (when Yjs fails)
âœ… Sync state tracking
âœ… Offline-first cache
2. IndexedDB (Yjs CRDT - Separate Database)
Location: Browser storage
Database Name: mdreader-{documentId} (one per document!)
Format:
Binary Yjs CRDT Operations (LargeBinary)â”œâ”€â”€ Update 1: User typed "Hello"â”œâ”€â”€ Update 2: User deleted "o"â”œâ”€â”€ Update 3: User added bold formattingâ””â”€â”€ Current State: Merged CRDT document
Purpose:
âœ… Real-time collaboration (CRDT operations)
âœ… Conflict-free merging (Yjs automatic resolution)
âœ… Offline editing (stores all operations locally)
âœ… Undo/redo (operation history)
Created by:
import { IndexeddbPersistence } from 'y-indexeddb';const persistence = new IndexeddbPersistence(`mdreader-${documentId}`, ydoc);
3. PostgreSQL (Cloud Backend)
Location: Server database
Table: documents
Format:
CREATE TABLE documents (  id UUID PRIMARY KEY,  title VARCHAR(200),  content TEXT,                    -- ğŸ“ PLAIN TEXT MARKDOWN (fallback)  yjs_state BYTEA,                 -- ğŸ§¬ BINARY YJS STATE (authoritative)  yjs_version INTEGER,             -- Version counter  workspace_id UUID,  -- ... other fields);
Purpose:
âœ… Cloud backup (persistent storage)
âœ… Multi-device sync (access from anywhere)
âœ… Collaboration (shared CRDT state)
âœ… Version history (snapshots)
How Binary is Exposed:
@propertydef yjs_state_b64(self) -> Optional[str]:    """Convert binary to base64 for API"""    if self.yjs_state:        return base64.b64encode(self.yjs_state).decode('utf-8')    return None
ğŸ¯ The Two Formats
Format 1: Plain Text Markdown (ğŸ“ Metadata/Cache)
Stored in:
âœ… content field in IndexedDB (DocumentMeta)
âœ… content field in PostgreSQL (TEXT)
Purpose:
Search/indexing
Quick previews
Legacy fallback
Markdown export
Example:
.
# Hello WorldThis is **bold** and this is *italic*.
Format 2: Yjs Binary (ğŸ§¬ CRDT Truth)
Stored in:
âœ… Separate Yjs IndexedDB (mdreader-{documentId})
âœ… yjsStateB64 field in IndexedDB (DocumentMeta - base64 string)
âœ… yjs_state field in PostgreSQL (BYTEA - binary)
Purpose:
Real-time collaboration
Conflict-free merging
Operation history
Rich text formatting
Example (binary, not human-readable):
0x01 0x03 0xa8 0x8d 0xa2 0x82 0x04 0x00 0x07 0x01 0x67 ...(CRDT operations encoding document structure + content + formatting)
Transmitted as Base64:
"AQOojaKCBAAHAQdjb250ZW50AwlwYXJhZ3JhcGgHAKiNooIEAAYEAKiNooIEAR9..."
ğŸ”„ Data Flow Example
Creating a Document Offline:
1. User types in editor   â†“2. Yjs document updated (in-memory)   â†“3. IndexeddbPersistence saves to:   IndexedDB: "mdreader-{documentId}"   â””â”€â”€ Binary CRDT operations   â†“4. Editor serializes to Markdown:   "# Title\n\nContent"   â†“5. autoSaveDocument() saves to:   IndexedDB: "MDReaderGuest"   â”œâ”€â”€ content: "# Title\n\nContent" (plain text)   â””â”€â”€ yjsStateB64: "AQOoja..." (binary as base64)
Pushing to Cloud:
1. User clicks "Push to Cloud"   â†“2. selectiveSyncService.pushDocument()   â”œâ”€â”€ Reads: content (markdown)   â”œâ”€â”€ Reads: yjsStateB64 (binary state)   â””â”€â”€ POST /api/v1/documents       {         "title": "My Doc",         "content": "# Title\n\nContent",         "yjs_state_b64": "AQOoja..."       }   â†“3. Backend decodes base64 â†’ binary   â”œâ”€â”€ Saves content as TEXT   â””â”€â”€ Saves yjs_state as BYTEA
Loading a Document:
1. User selects document   â†“2. DocumentDataContext.getDocument()   â”œâ”€â”€ Fetches from IndexedDB or API   â”œâ”€â”€ Gets: content + yjsStateB64   â””â”€â”€ Calls: YjsHydrationService   â†“3. YjsHydrationService.hydrateDocument()   Priority:   1ï¸âƒ£ yjsStateB64 exists?       â†’ Decode base64 â†’ Binary      â†’ Y.applyUpdate(ydoc, binary)      â†’ âœ… CRDT state restored   2ï¸âƒ£ No binary?      â†’ Use content (markdown)      â†’ Convert to HTML      â†’ Initialize Yjs from HTML
ğŸ’¡ Why Two Formats?
Format	Use Case	Pros	Cons
Plain Text	Metadata, search, export	âœ… Human-readable<br>âœ… Easy to index<br>âœ… Portable	âŒ No formatting<br>âŒ No conflict resolution<br>âŒ No real-time collab
Yjs Binary	Real-time editing, collaboration	âœ… CRDT (conflict-free)<br>âœ… Rich formatting<br>âœ… Operation history<br>âœ… Undo/redo	âŒ Binary (not human-readable)<br>âŒ Requires Yjs to decode<br>âŒ Larger size
ğŸ“ Key Takeaways
Content is stored in TWO formats: Plain text (metadata) + Yjs binary (truth)
Yjs binary is authoritative: When it exists, it overrides plain text
Plain text is fallback: Used when Yjs fails or for search/export
Three storage locations: 2 IndexedDB databases + 1 PostgreSQL
Base64 encoding: Binary is encoded for JSON transmission